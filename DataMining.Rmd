---
title: "Case Studies in Data Mining with R"
author: "Yi-Ju Tseng"
institute: "Chung Gung University"
date: "2020/05/15"
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---
class: inverse, center, middle
# Reviews
---

## R and RStudio

[R](https://cloud.r-project.org/) : Core (engine)

```{r echo=FALSE,out.height="400px", fig.align='center'}
knitr::include_graphics("https://www.teslarati.com/wp-content/uploads/2018/07/model-3-drivetrain-1.jpg")
```

[Source](https://www.teslarati.com/tesla-patent-more-efficient-electric-motors/)

---
## R and RStudio

[RStudio](https://www.rstudio.com/products/rstudio/download/#download) : IDE (dashboard)

```{r echo=FALSE,out.height="400px", fig.align='center'}
knitr::include_graphics("https://raw.githubusercontent.com/DHLab-TSENG/emr_slide/master/emr_package-figure/dashboard.jpg")
```

[Source](https://www.theverge.com/2015/3/19/8260295/tesla-user-interface-redesign-concept)

---

## How to use RStudio for the first time
.pull-left[
4 Blocks in RStudio：
- Source editor  -> edit the codes here
- Console -> get the results here
]
.pull-right[
</br>
- Environment/...
- File/Figure/...
]

```{r echo=FALSE,out.height="350px",fig.align='center'}
knitr::include_graphics("https://raw.githubusercontent.com/DHLab-TSENG/emr_slide/master/emr_package-figure/RStudio.png")
```

---
## R and R Packages

R : Core (iPhone)

```{r echo=FALSE,out.height = "400px",fig.align='center'}
knitr::include_graphics("https://store.storeimages.cdn-apple.com/4982/as-images.apple.com/is/iphone-xr-white-select-201809?wid=940&hei=1112&fmt=png-alpha&qlt=80&.v=1551226036668")
```

---
## R and R Packages

R Packages : APP

```{r echo=FALSE,out.height = "400px",fig.align='center'}
knitr::include_graphics("https://3c.yipee.cc/wp-content/uploads/2019/06/a7ffbaa3df50d7cafe6801a8a8d7a3bf-620x320.jpg")
```

[Source](https://www.apple.com/)

---
## Install and Use Packages

- Install

```{r tidy=FALSE, eval=FALSE}
install.packages("tidymodels")  #<<
library(tidymodels)
```

--


- Use

```{r tidy=FALSE, eval=FALSE}
install.packages("tidymodels")  
library(tidymodels) #<<
```
```{r echo=F}
library(tidymodels)
```

---
## Pipe %>%

---

class: inverse, center, middle

# Get Started - Data Import

---

## 建模範例資料 - 載入

- `mlbench`套件內附的`PimaIndiansDiabetes2`資料集
- Outcome為是否有糖尿病  **diabetes**欄位
- 可輸入`?PimaIndiansDiabetes2`查看所有欄位變數

```{r}
library(mlbench)
data("PimaIndiansDiabetes2") # 載入資料
```
---

## 建模範例資料 - 初探

- 用`glimpse()`函數看一下各資料的**型態**跟資料**筆數**
```{r}
glimpse(PimaIndiansDiabetes2)
```
- 發現有不少空值，要決定如何處理

---

## 建模範例資料 - Outcome比例

- 在處理空值前，先看**diabetes**欄位中有病跟沒病的人數與比例

```{r}
PimaIndiansDiabetes2 %>% 
  count(diabetes) %>% 
  mutate(prop = n/sum(n))
```

- 大概是65:35，有些不平均，但還行

---
## 刪除空（遺漏）值

- 臨床研究通常會刪除有**缺值**的資料
- 為了後續敘述性統計方便，若狀況許可，會在第一步刪除資料
- 某些演算法不能用有空值的資料建模


```{r}
PimaIndiansDiabetes2<-
  PimaIndiansDiabetes2 %>% #<<
  filter(complete.cases(PimaIndiansDiabetes2)) 
```


---
## 刪除遺漏值

- 臨床研究通常會刪除有**缺值**的資料
- 為了後續敘述性統計方便，若狀況許可，會在第一步刪除資料
- 某些演算法不能用有空值的資料建模


```{r}
PimaIndiansDiabetes2<-
  PimaIndiansDiabetes2 %>% 
  filter(complete.cases(PimaIndiansDiabetes2)) #<<
```

- `filter()`為`dplyr`套件的功能，可針對資料列(row)做子集

--

.pull-left[
```{r echo=F}
knitr::kable(data.frame(ID=1:3,Name=letters[1:3]))
```
]
--
.pull-right[
```{r echo=F}
knitr::kable(data.frame(ID=c(1,3),Name=letters[c(1,3)]))
```
]

---
## 刪除遺漏值

- 臨床研究通常會刪除有缺值的資料
- 為了後續敘述性統計方便，若狀況許可，會在第一步刪除資料
- 某些演算法不能用有空值的資料建模


```{r}
PimaIndiansDiabetes2<-
  PimaIndiansDiabetes2 %>% 
  filter(complete.cases(PimaIndiansDiabetes2)) #<<
```

- `filter()`為`dplyr`套件的功能，可針對資料列(row)做子集
- 用`complete.cases()`辨識是否為完整資料，若沒有空值，回傳TRUE

---
## 刪除遺漏值後 - Outcome比例

刪除空後資料筆數有些微改變，但大概還是6x:3x的比例

```{r}
PimaIndiansDiabetes2 %>% 
  count(diabetes) %>% 
  mutate(prop = n/sum(n))
```

---
class: inverse, center, middle

# 敘述性統計

---
## 醫學資料分析中的敘述性統計


- 通常是論文中的第一個表格
```{r echo=FALSE,out.height="350px",fig.align='center'}
knitr::include_graphics("https://raw.githubusercontent.com/yijutseng/RCourses/master/figures/tableoneExample.png")
```
[Source](https://www.sciencedirect.com/science/article/abs/pii/S1386505618311213)
---
## 單變量分析


```{r}
library(tableone)
tableone<-
  CreateTableOne(data=PimaIndiansDiabetes2)
print(tableone)
```

---
## 單變量分析 - 依outcome分組

```{r}
library(tableone)
tableone<-
  CreateTableOne(data=PimaIndiansDiabetes2,
                 strata = "diabetes")#<<
print(tableone)
```

---
## 單變量分析 - 產生方便貼到Excel的表格

```{r}
library(tableone)
tableone<-
  CreateTableOne(data=PimaIndiansDiabetes2,
                 strata = "diabetes")
print(tableone,quote = T)#<<
```

---
## 單變量分析 - Excel處理步驟

---
class: inverse, center, middle

# 開始建模

---

## 訓練/調整與驗證模型效能策略

JAMA在2019年刊登一篇有趣的文章，名稱為How to Read Articles That Use Machine Learning - Users’ Guides to the Medical Literature [下載](https://jamanetwork.com/journals/jama/fullarticle/2754798)，內文中有提到在機器學習時代，如何建立與預測模型，跟之前又有什麼不同，並用下圖來解釋差異

```{r echo=F}
knitr::include_graphics("https://cdn.jamanetwork.com/ama/content_public/journal/jama/938259/jug190001f2.png?Expires=2147483647&Signature=cU6lP2ZYSdn9MyOakMWobXQF2h6LSPCExTP1q7x74zRH7gDgkRSqshXWADmcQUz0XJVK~aVPK3cb-~shWQ6vd6EF4FwIcR8NBXMlGq1sLDR5dXLwpb~qoEYzXvg03zCz2l0AHmdlFxy4IGYGG3ilBfuPh1SCweskxtaUfsWqGsUcwc6FNo3KjaR9j58eJeZOnBEr6a2OF2m~XlEOnT1W3vaYn2-fuGZLAQR88XcUGWp1LYgc6GnDTO1s7zj5m9mYhlL-CeOaLXQNGrSl6fAvw6LisZW-f2tChvIaDfCd4vuuNw-Q1V6sjm-jgUehMt8wjrc61YW6WqyIC9mF6VGzzg__&Key-Pair-Id=APKAIE5G5CRDK6RD3PGA")
```
[圖片來源](https://jamanetwork.com/journals/jama/fullarticle/2754798)


在所謂的"非"機器學習模型(圖上半部)，通常可分訓練組與測試組，在作者定義為Development set和Validation set，重要的概念是訓練模型時，一定要記得先把測試組資料分出來，不可以用到這部分資料來訓練模型，最後才能得到真實的預測結果 (完全沒偷看答案的意思)。

在圖下半部，作者將此法命名為**3-step process**，主要差異是在訓練模型時多了一組**參數調整資料集**，原因是因為在多種機器學習模型中，有可調整的參數，在圖中稱為Hyperparameters，為了讓調整效果更好，會將訓練組再切分成小組，用來決定**最佳參數**，決定好以後，才用所有訓練組資料搭配最佳參數訓練模型，最後再用測試組做測試。

以下用邏輯迴歸歸Logistic Regression示範此圖上半部**不調參數**的作法，以及用隨機森林Random Forest示範此圖下半部**需要調整參數**的作法。

---
# 訓練組、測試組資料分割

不管要不要調參數，都需要分割訓練組與測試組，因此在進入兩個範例前，先將訓練組與測試組切好。

用`initial_split()`函數將資料分成訓練組與測試組，第一個參數放資料，第二個參數`prop`放訓練組測試組比例，第三個參數`strata`放分組抽樣依據。需要設定分組抽樣依據是因為若是整批資料隨機抽樣，很有可能在測試組或是訓練組會少一整個組別的資料(剛好都沒抽到的意思)，所以就分組，個別抽某個比例的人當訓練組，剩下的就當測試組。切割完後，用`training()`和`testing()`函數將訓練組測試組正式分開。

這邊要特別注意的是，因為`initial_split()`函數有隨機的概念，為了讓每次的實驗結果相同，我們會在有隨機事件前設定seed，作為隨機的依據，讓隨機每次都一樣，才不會每次跑都是不一樣的結果，這樣就無法產生可重複的實驗結果。

```{r}
set.seed(123)
splits<- initial_split(PimaIndiansDiabetes2, 
                       prop=(3/4),
                       strata = diabetes)
DM_train<- training(splits)
DM_test<- testing(splits)
```

分組完後，查看訓練組的生病比例
```{r}
DM_train %>% 
  count(diabetes) %>% 
  mutate(prop = n/sum(n))
```

查看測試組的生病比例
```{r}
DM_test %>% 
  count(diabetes) %>% 
  mutate(prop = n/sum(n))
```

---
# 建立資料前處理“食譜”

資料前處理也是建立兩種模型都必須經歷的方法，因此提到最前方說明，前處理有很多方法，包括將類別變項轉為虛擬變項(dummy variables)，數值變項取log，數值變項正規化，以及日期資料處理等。

首先使用`recipe()`函數，設定模型訓練公式`diabetes ~ .`以及訓練用資料`DM_train`，要注意這邊只能用**訓練組資料**，不能用全部的資料。公式的意思是用`~`前方的`diabetes`當成outcome (想要預測的值)，`~`後方的`.`代表其他所有剩下的欄位都當成predictors (又稱variables 或是 features，為預測基礎)。

完成模型公式與資料設定後，就開始逐一加上想要做的資料前處理方法，在這邊列舉幾項我認為以此案例可能需要做的前處理

- `step_naomit(everything(), skip = TRUE)` 如果沒有在一開始將NA資料刪掉，通常要去除NA值
- `step_rose(diabetes)` 其實這個資料有病沒病的人沒差太多，只是呈現一下可以在此步驟設定oversampleing或是undersampling，這邊是指使用ROSE作為oversampling的演算法
- `step_dummy(all_nominal(), -all_outcomes())` 將所有的類別變項轉成虛擬變項，除了Outcome以外
- `step_zv(all_predictors())` 若有變項都是一樣的值，刪掉。舉例來說，若是整個資料都是女性，那性別欄位就不用拿來當作features了
- `step_normalize(all_predictors())` 將所有數值變項正規化

還有很多其他的前處理方法，可以參考`recipe()`函數的[說明文件](https://recipes.tidymodels.org/reference/recipe.html)

```{r}
gen_recipe <- 
  recipe(diabetes ~ ., data = DM_train) %>% 
  step_dummy(all_nominal(), -all_outcomes()) %>% 
  step_zv(all_predictors()) %>% 
  step_normalize(all_predictors())
summary(gen_recipe)
```

---
class: inverse, center, middle

# 邏輯迴歸Logistic Regression模型建立與效能評估範例

---
## Step 1 設定用邏輯迴建立模型

這邊以邏輯迴歸為例，用`logistic_reg()`函數與`set_engine("glm")`設定模型建立演算法為邏輯迴歸

```{r}
lr_mod <- 
  logistic_reg() %>% 
  set_engine("glm")
```
---
## Step 2 設定建模流程workflow

workflow將建模 (model)與資料前處理方法 (recipe)串成單一工作流程workflow

```{r}
lr_wflow <- 
  workflow() %>% 
  add_model(lr_mod) %>% 
  add_recipe(gen_recipe)
lr_wflow
```
---
## Step 3 訓練模型

使用剛剛串起來的工作流程，加上`fit()`函數，完成建模，並用`pull_workflow_fit()`與`tidy()`呈現建模結果，注意這裡也是只能用**訓練組資料**`DM_train`

```{r}
lr_fit <- 
  lr_wflow %>% 
  fit(data=DM_train)

lr_fit %>% 
  pull_workflow_fit() %>% 
  tidy()
```
---
## Step 4 使用模型與測試組資料驗證模型效能

使用`predict()`函數，用剛剛訓練出來的模型`lr_fit`以及一開始分出的測試組`DM_test`產生預測結果，注意這邊要用測試組資料

```{r}
lr_pred <- lr_fit %>% 
  predict(DM_test)
lr_pred
```

將預測結果與答案結合

```{r}
lr_pred <- lr_fit %>%
  predict(DM_test) %>% 
  bind_cols(DM_test %>% select(diabetes)) 
lr_pred
```

使用`accuracy()`函數，輸入預測結果與真實答案計算正確率

```{r}
lr_pred %>% 
  accuracy(truth = diabetes, 
          .pred_class)
```

但很多時候我們需要Area under the ROC curve，此時我們需要的不是直接pos或neg的結果，我們需要的是連續性的預測數值，這邊可將`predict()`函數的`type`參數設定為prob，即回傳各組預測值

```{r}
lr_pred <- lr_fit %>%
  predict(DM_test,
          type = "prob")%>% 
  bind_cols(DM_test %>% select(diabetes)) 
lr_pred
```


得到各組預測值後，可用`roc_curve()`畫ROC curve
```{r}
lr_pred %>% 
  roc_curve(truth = diabetes, 
            .pred_pos) %>% 
  autoplot()
```

當然也能用`roc_auc()`算Area under the ROC curve

```{r}
lr_pred %>% 
  roc_auc(truth = diabetes, 
          .pred_pos)
```


以上就是使用邏輯迴歸建立模型與效能測試流程，可以發現完全沒有調整任何參數，因基本邏輯迴歸不用調參數。

---
class: inverse, center, middle

# 隨機森林Random Forest模型建立、參數調整與效能評估範例
---
## Step 1 設定平行處理

因為模型參數調整需要一直不斷建立模型與測試，所以設定平行處理會快一些，`tidymodels`套組支援平行處理，細節可參考[官方文件](https://tune.tidymodels.org/articles/extras/optimizations.html)

```{r}
all_cores <- parallel::detectCores(logical = FALSE)
library(doParallel)
cl <- makePSOCKcluster(all_cores)
registerDoParallel(cl)
```

---
## Step 2 設定用隨機森林建立模型以及要調整的參數

這邊以隨機森林為例，用`rand_forest()`函數與`set_engine("ranger")`設定模型建立演算法為基於`ranger`套件的隨機森林演算法，因為隨機森林有迴歸版與分類版，因此使用`set_mode("classification")`設定我們要用分類演算法。

在隨機森林`rand_forest()`函數中，可設定幾個參數，說明如下:

- mtry: 在切割節點時，隨機抽取n個特徵，並從中選最適合的特徵當作節點
- min_n: 每個節點的最小資料數，如果設為10，當該節點的資料剩十筆或更少時，就不會再切割
- trees: 建模要用幾棵樹

在這個範例中，我將要建幾棵樹設定為1000，其他兩個參數則是想用交叉驗證法(Cross Validation)來調整，因此將想調的參數值設為`tune()`，表示這些參數要調，不想在現階段指定。
```{r eval=F}
install.packages("ranger")
```

```{r}
rf_mod <- 
  rand_forest(mtry = tune(), min_n = tune(), 
              trees = 1000) %>% 
  set_engine("ranger") %>% 
  set_mode("classification")

rf_mod
```

---
## Step 3 設定建模流程workflow

建模流程同邏輯迴歸，將模型與資料前處理方法串接成一個工作流程

```{r}
rf_wflow <- workflow() %>%
  add_model(rf_mod) %>%
  add_recipe(gen_recipe)
```

---
## Step 4 參數調整組資料分割

剛剛有提到我想要調整的參數為mtry以及min_n，調整的方法為交叉驗證法(Cross Validation)，這邊用`tidymodels`官網的圖來說明架構

```{r echo=F}
knitr::include_graphics("https://www.tidymodels.org/start/resampling/img/resampling.svg")
```
[圖片來源](https://www.tidymodels.org/start/resampling/)

在圖中，首先將所有資料分成測試組訓練組，也就是本篇文章一開始做的切割，為了調整參數，我們會再切訓練組的資料，做為測試各參數效能的**調整訓練**以及**調整測試**。

切割**參數調整組**有很多種方法，可以用**bootstrap**法隨機抽，也可使用這邊的**交叉驗證**範例，交叉驗證的概念如下圖的下半部

```{r echo=F}
knitr::include_graphics("https://www.frontiersin.org/files/Articles/411217/fmicb-09-02393-HTML/image_m/fmicb-09-02393-g002.jpg")
```
[圖片來源](https://doi.org/10.3389/fmicb.2018.02393)

圖片下半部為5-fold Cross Validation的示意圖，可以看到每份資料都會被拿來當作**調整訓練**以及**調整測試**組，經過幾次測試後，用**調整測試**組的效能來決定一組最佳參數。

這邊我們使用10-fold Cross Validation為例，先用`vfold_cv()`函數，設定分割基準為**訓練組**，要分10份`v=10`，分割時一樣要注意糖尿病的比例不能差太多

```{r}
set.seed(345)
folds <- vfold_cv(DM_train, v = 10,
                  strata = diabetes)
folds
```
---
## Step 5 調整參數

完成分割後，可將之前的建模流程串接至`tune_grid()`函數，這個函數可以設定參數調整的方法，首先是調整要用的**參數調整組資料**`resamples = folds`，要測試幾組參數` grid = 50`，測試時要用什麼效能評估方式，這邊設定為Area under the ROC curve `metrics = metric_set(roc_auc)`。因為要重複訓練測試多次，因此這程式碼執行會需要一些時間。

```{r}
rf_res <- 
  rf_wflow %>% 
  tune_grid(
    resamples = folds,
    grid = 50,
    metrics = metric_set(roc_auc),
    control=control_resamples(save_pred = TRUE)
    )

```


執行完後，可用`collect_metrics()`查看各參數效能

```{r}
rf_res %>%
  collect_metrics()
```

也可畫個圖呈現參數調整對效能的影響，由圖可知在這個範例中min_n越大效能越好

```{r}
rf_res %>%
  collect_metrics() %>%
  mutate(mtry = factor(mtry)) %>%
  ggplot(aes(min_n, mean, color = mtry)) + 
  geom_line(size=1) +
  scale_x_log10(labels = scales::label_number()) 
```

搭配`show_best()`函數可呈現Area under the ROC curve最優的幾組參數

```{r}
rf_res %>%
  show_best("roc_auc")
```


---
## Step 6 使用最佳參數與訓練組資料建立最終模型

在完成參數調整後，我們會使用最佳參數(意即Area under the ROC curve最高的一組參數)來建立最終模型，用`select_best()`函數可選出最好的一組參數`best_rf`

```{r}
best_rf <- rf_res %>%
  select_best("roc_auc")
best_rf
```

為了將參數節合至原有的建模流程，可用`finalize_workflow()`函數輸入剛剛選出的最佳參數`best_rf`，建立一個**最終建模流程**

```{r}
final_wflow <- 
  rf_wflow %>% 
  finalize_workflow(best_rf)

final_wflow
```

**最終建模流程**建立後，即可用`fit()`建模，注意這邊用的是完整的訓練資料`DM_train`

```{r}
final_rf_model <- 
  final_wflow %>%
  fit(data = DM_train) 

final_rf_model
```

---
## Step 7 用測試組資料驗證最終模型效能

使用`predict()`函數，用剛剛訓練出來的模型`final_rf_model`以及一開始分出的測試組`DM_test`產生預測結果，注意這邊要用測試組資料

```{r}
rf_pred <- final_rf_model %>% 
  predict(DM_test)
rf_pred
```

將預測結果與答案結合
```{r}
rf_pred <- final_rf_model %>%
  predict(DM_test) %>% 
  bind_cols(DM_test %>% select(diabetes)) 
rf_pred
```

使用預測結果與真實答案計算正確率
```{r}
rf_pred %>% 
  accuracy(truth = diabetes, 
          .pred_class)
```

但很多時候我們需要Area under the ROC curve，此時我們需要的不是直接pos或neg的結果，我們需要的是連續性的預測數值，這邊可將`predict()`函數的`type`參數設定為prob，即回傳各組預測值

```{r}
rf_pred <- final_rf_model %>%
  predict(DM_test,
          type = "prob")%>% 
  bind_cols(DM_test %>% select(diabetes)) 
rf_pred
```


得到各組預測值後，可用`roc_curve()`畫ROC curve
```{r}
rf_pred %>% 
  roc_curve(truth = diabetes, 
            .pred_pos) %>% 
  autoplot()
```

當然也能用`roc_auc()`算Area under the ROC curve
```{r}
rf_pred %>% 
  roc_auc(truth = diabetes, 
          .pred_pos)
```


以上就是使用隨機森林建立模型、調整參數以及與效能測試流程，多了使用交叉驗證法調整參數的步驟。


---
# Hello World

Install the **xaringan** package from [Github](https://github.com/yihui/xaringan):

```{r eval=FALSE, tidy=FALSE}
devtools::install_github("yihui/xaringan")
```

--

You are recommended to use the [RStudio IDE](https://www.rstudio.com/products/rstudio/), but you do not have to.

- Create a new R Markdown document from the menu `File -> New File -> R Markdown -> From Template -> Ninja Presentation`;<sup>1</sup>

--

- Click the `Knit` button to compile it;

--

- or use the [RStudio Addin](https://rstudio.github.io/rstudioaddins/)<sup>2</sup> "Infinite Moon Reader" to live preview the slides (every time you update and save the Rmd document, the slides will be automatically reloaded in RStudio Viewer.

.footnote[
[1] 中文用户请看[这份教程](http://slides.yihui.org/xaringan/zh-CN.html)

[2] See [#2](https://github.com/yihui/xaringan/issues/2) if you do not see the template or addin in RStudio.
]

---
background-image: url(`r xaringan:::karl`)
background-position: 50% 50%
class: center, bottom, inverse

# You only live once!

---

# Hello Ninja

As a presentation ninja, you certainly should not be satisfied by the "Hello World" example. You need to understand more about two things:

1. The [remark.js](https://remarkjs.com) library;

1. The **xaringan** package;

Basically **xaringan** injected the chakra of R Markdown (minus Pandoc) into **remark.js**. The slides are rendered by remark.js in the web browser, and the Markdown source needed by remark.js is generated from R Markdown (**knitr**).

---

# remark.js

You can see an introduction of remark.js from [its homepage](https://remarkjs.com). You should read the [remark.js Wiki](https://github.com/gnab/remark/wiki) at least once to know how to

- create a new slide (Markdown syntax<sup>*</sup> and slide properties);

- format a slide (e.g. text alignment);

- configure the slideshow;

- and use the presentation (keyboard shortcuts).

It is important to be familiar with remark.js before you can understand the options in **xaringan**.

.footnote[[*] It is different with Pandoc's Markdown! It is limited but should be enough for presentation purposes. Come on... You do not need a slide for the Table of Contents! Well, the Markdown support in remark.js [may be improved](https://github.com/gnab/remark/issues/142) in the future.]

---
background-image: url(`r xaringan:::karl`)
background-size: cover
class: center, bottom, inverse

# I was so happy to have discovered remark.js!

---
class: inverse, middle, center

# Using xaringan

---

# xaringan

Provides an R Markdown output format `xaringan::moon_reader` as a wrapper for remark.js, and you can use it in the YAML metadata, e.g.

```yaml
---
title: "A Cool Presentation"
output:
  xaringan::moon_reader:
    yolo: true
    nature:
      autoplay: 30000
---
```

See the help page `?xaringan::moon_reader` for all possible options that you can use.

---

# remark.js vs xaringan

Some differences between using remark.js (left) and using **xaringan** (right):

.pull-left[
1. Start with a boilerplate HTML file;

1. Plain Markdown;

1. Write JavaScript to autoplay slides;

1. Manually configure MathJax;

1. Highlight code with `*`;

1. Edit Markdown source and refresh browser to see updated slides;
]

.pull-right[
1. Start with an R Markdown document;

1. R Markdown (can embed R/other code chunks);

1. Provide an option `autoplay`;

1. MathJax just works;<sup>*</sup>

1. Highlight code with `{{}}`;

1. The RStudio addin "Infinite Moon Reader" automatically refreshes slides on changes;
]

.footnote[[*] Not really. See next page.]

---

# Math Expressions

You can write LaTeX math expressions inside a pair of dollar signs, e.g. &#36;\alpha+\beta$ renders $\alpha+\beta$. You can use the display style with double dollar signs:

```
$$\bar{X}=\frac{1}{n}\sum_{i=1}^nX_i$$
```

$$\bar{X}=\frac{1}{n}\sum_{i=1}^nX_i$$

Limitations:

1. The source code of a LaTeX math expression must be in one line, unless it is inside a pair of double dollar signs, in which case the starting `$$` must appear in the very beginning of a line, followed immediately by a non-space character, and the ending `$$` must be at the end of a line, led by a non-space character;

1. There should not be spaces after the opening `$` or before the closing `$`.

1. Math does not work on the title slide (see [#61](https://github.com/yihui/xaringan/issues/61) for a workaround).

---

# R Code

```{r comment='#'}
# a boring regression
fit = lm(dist ~ 1 + speed, data = cars)
coef(summary(fit))
dojutsu = c('地爆天星', '天照', '加具土命', '神威', '須佐能乎', '無限月読')
grep('天', dojutsu, value = TRUE)
```


---

# Tables

If you want to generate a table, make sure it is in the HTML format (instead of Markdown or other formats), e.g.,

```{r}
knitr::kable(head(iris), format = 'html')
```

---

# HTML Widgets

I have not thoroughly tested HTML widgets against **xaringan**. Some may work well, and some may not. It is a little tricky.

Similarly, the Shiny mode (`runtime: shiny`) does not work. I might get these issues fixed in the future, but these are not of high priority to me. I never turn my presentation into a Shiny app. When I need to demonstrate more complicated examples, I just launch them separately. It is convenient to share slides with other people when they are plain HTML/JS applications.

See the next page for two HTML widgets.

---

```{r out.width='100%', fig.height=6, eval=require('leaflet')}
library(leaflet)
leaflet() %>% addTiles() %>% setView(-93.65, 42.0285, zoom = 17)
```

---

```{r eval=require('DT'), tidy=FALSE}
DT::datatable(
  head(iris, 10),
  fillContainer = FALSE, options = list(pageLength = 8)
)
```

---

# Some Tips

- When you use the "Infinite Moon Reader" addin in RStudio, your R session will be blocked by default. You can click the red button on the right of the console to stop serving the slides, or use the _daemonized_ mode so that it does not block your R session. To do the latter, you can set the option

    ```r
    options(servr.daemon = TRUE)
    ```
    
    in your current R session, or in `~/.Rprofile` so that it is applied to all future R sessions. I do the latter by myself.
    
    To know more about the web server, see the [**servr**](https://github.com/yihui/servr) package.

--

- Do not forget to try the `yolo` option of `xaringan::moon_reader`.

    ```yaml
    output:
      xaringan::moon_reader:
        yolo: true
    ```

---

# Some Tips

- Slides can be automatically played if you set the `autoplay` option under `nature`, e.g. go to the next slide every 30 seconds in a lightning talk:

    ```yaml
    output:
      xaringan::moon_reader:
        nature:
          autoplay: 30000
    ```

--

- A countdown timer can be added to every page of the slides using the `countdown` option under `nature`, e.g. if you want to spend one minute on every page when you give the talk, you can set:

    ```yaml
    output:
      xaringan::moon_reader:
        nature:
          countdown: 60000
    ```

    Then you will see a timer counting down from `01:00`, to `00:59`, `00:58`, ... When the time is out, the timer will continue but the time turns red.
    
---

# Some Tips

- The title slide is created automatically by **xaringan**, but it is just another remark.js slide added before your other slides.

    The title slide is set to `class: center, middle, inverse, title-slide` by default. You can change the classes applied to the title slide with the `titleSlideClass` option of `nature` (`title-slide` is always applied).

    ```yaml
    output:
      xaringan::moon_reader:
        nature:
          titleSlideClass: [top, left, inverse]
    ```
    
--

- If you'd like to create your own title slide, disable **xaringan**'s title slide with the `seal = FALSE` option of `moon_reader`.

    ```yaml
    output:
      xaringan::moon_reader:
        seal: false
    ```

---

# Some Tips

- There are several ways to build incremental slides. See [this presentation](https://slides.yihui.org/xaringan/incremental.html) for examples.

- The option `highlightLines: true` of `nature` will highlight code lines that start with `*`, or are wrapped in `{{ }}`, or have trailing comments `#<<`;

    ```yaml
    output:
      xaringan::moon_reader:
        nature:
          highlightLines: true
    ```

    See examples on the next page.

---

# Some Tips


.pull-left[
An example using a leading `*`:

    ```r
    if (TRUE) {
    ** message("Very important!")
    }
    ```
Output:
```r
if (TRUE) {
* message("Very important!")
}
```

This is invalid R code, so it is a plain fenced code block that is not executed.
]

.pull-right[
An example using `{{}}`:

````
`r ''````{r tidy=FALSE}
if (TRUE) {
*{{ message("Very important!") }}
}
```
````
Output:
```{r tidy=FALSE}
if (TRUE) {
{{ message("Very important!") }}
}
```

It is valid R code so you can run it. Note that `{{}}` can wrap an R expression of multiple lines.
]

---

# Some Tips

An example of using the trailing comment `#<<` to highlight lines:

````markdown
`r ''````{r tidy=FALSE}
library(ggplot2)
ggplot(mtcars) + 
  aes(mpg, disp) + 
  geom_point() +   #<<
  geom_smooth()    #<<
```
````

Output:

```{r tidy=FALSE, eval=FALSE}
library(ggplot2)
ggplot(mtcars) + 
  aes(mpg, disp) + 
  geom_point() +   #<<
  geom_smooth()    #<<
```
